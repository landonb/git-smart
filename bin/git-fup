#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-smart#ðŸ’¡
# License: MIT. Please find more in the LICENSE file.

# Creates a fixup commit and then rebases it where it needs to be.
#
# Assuming you've added the files you want fixed-up, e.g.,
#
#   git add {some-changes}
#
# Then running `git fup {commit}` is similar to the following steps:
#
#   git commit --no-verify --fixup={commit}
#   git add -A && git ci -m WIP
#   git rebase -i --autosquash {commit}^
#   # Save the file
#   git pop1  # Undo the WIP.

# USAGE: git fup {commit}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_fixup_and_rebase () {
  local commit="$1"

  local wip_commit_message="WIP"

  set -e

  # The `git --no-pager diff --name-only` returns paths relative to
  # root, which is used by must_not_have_unstaged_hard_link_changes.
  git_root() {
    git rev-parse --show-toplevel
  }

  cd "$(git_root)"

  must_not_have_unstaged_hard_link_changes

  # Aka `git fu`.
  git commit --no-verify --fixup ${commit}

  local pop_after=false
  if [ -n "$(git_status_porcelain)" ]; then
    # Untracked, Unstaged, or Staged changes not committed.
    pop_after=true
    # Aka `git wip`
    git add -A
    git commit --no-verify -m "${wip_commit_message}"
  fi

  # Have the interactive rebase sequence editor complete automatically
  # by specifying the Bash `:` no-op.
  # See:
  #   https://stackoverflow.com/questions/29094595/
  #     git-interactive-rebase-without-opening-the-editor

  # Aka `git ria ${commit}^`
  GIT_SEQUENCE_EDITOR=: git rebase -i --autosquash ${commit}^

  # Here we pop the temporary "WIP" commit that we made before the rebase.
  # - But beware a failed rebase -- we don't want to pop the latest commit
  #   if the rebase stopped to ask the user to intervene, because that's
  #   nor our temporary commit.
  # - Most likely, we only need to check that the repo is tidy. If it's
  #   not tidy, the rebase failed.
  # - But we'll also do an extra paranoid check (or is it due diligence?)
  #   and verify that the latest commit has a "WIP" message (which isn't
  #   foolproof, and if we check after checking git-status, the fail-branch
  #   will likely never run, but at least we can say we tried).
  if ${pop_after}; then
    if [ -n "$(git_status_porcelain)" ]; then
      echo
      echo "OOPS! It looks like the rebase stopped."
      echo "- Reason: Git status reports the project is not tidy."
      echo "- Resolution: You're gonna have to take it from here!"
      return
    fi
    echo

    if [ "$(git_latest_commit_message)" != "${wip_commit_message}" ]; then
      echo
      echo "OOPS! It looks like the rebase stopped."
      echo "- Reason: The latest commit is not the \"WIP\" we made."
      echo "- Resolution: You're gonna have to take it from here!"
      return
    fi

    # The original safe-guard from 2021-05-03 only prompted the user.
    # FIXME/2022-10-13: If the previous safety checks (git-status) work,
    #                   we can remove this prompt.
    echo "It looks like the rebase was successful!"
    echo "- But this code is under test, so please confirm."
    echo
    echo "FIXME: Once you're sick of being prompted, remove this check."
    echo

    echo "Was rebase successful? [y/N] "
    read -n 1 yorn
    if [ "${yorn#y}" != "${yorn}" ] || [ "${yorn#Y}" != "${yorn}" ]; then
      # Aka `git pop1`.
      git reset --mixed @~1
      git --no-pager log -1 --pretty=oneline --abbrev-commit
    fi
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_status_porcelain () {
  git status --porcelain=v1
}

git_latest_commit_message () {
  git --no-pager log -1 --pretty=%B
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# BEWARE: git-reset is not nice to hard links -- if we were to WIP-commit
# uncommitted changes from a hard link, a git-reset breaks the hard link.
#
# - So examine changed files, and check if any have +1 links:
#     find . ! -name . -prune -links +1  # report files in current directory
#     find . ! -name . -prune ! -type d -links +1  # exclude directories
#     find . ! -name . ! -type d -links +1  # descend into directories
#   Check a single file instead...
#     find ${file} -prune ! -type d -links +1
#   List staged files (which we don't care about; these get fup'ed):
#     git --no-pager diff --name-only --cached
#     git --no-pager diff --name-only --staged  # Newer Git alias option
#   List modified, unstaged files (what we want to check for links):
#     git ls-files -m  # aka `git ls-files --modified`
#     git --no-pager diff --name-only
#   Altogether now:
#     git --no-pager diff --name-only | xargs -I {} find {} -links +1 | wc -l

must_not_have_unstaged_hard_link_changes () {
  if [ -n "$( \
    git --no-pager diff --name-only | xargs -I {} find {} -links +1 \
  )" ]; then
    echo "ERROR: Cannot process: There are hard links with unstaged changes."
    echo "       This command clobbers such hard links. You don't want that."
    echo "       HINT: Commit hard linked changes first, then retry git-fup."

    return 1
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  git_fixup_and_rebase "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

