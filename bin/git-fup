#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-smart#ðŸ’¡
# License: MIT. Please find more in the LICENSE file.

# Creates a fixup commit and then rebases it where it needs to be.
#
# Assuming you've added the files you want fixed-up, e.g.,
#
#   git add {some-changes}
#
# Then running `git fup {commit}` is similar to the following steps:
#
#   git commit --no-verify --fixup={commit}
#   git add -A && git ci -m WIP
#   git rebase -i --autosquash {commit}^
#   # Save the file
#   git pop1  # Undo the WIP.

# USAGE: git fup {commit}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_fixup_and_rebase () {
  local commit="$1"

  set -e

  must_not_have_unstaged_hard_link_changes

  # Aka `git fu`.
  git commit --no-verify --fixup ${commit}

  local pop_after=false
  if [ -n "$(git status --porcelain)" ]; then
    # Untracked, Unstaged, or Staged changes not committed.
    pop_after=true
    # Aka `git wip`
    git add -A
    git commit --no-verify -m WIP
  fi

  # Have the interactive rebase sequence editor complete automatically
  # by specifying the Bash `:` no-op.
  # See:
  #   https://stackoverflow.com/questions/29094595/
  #     git-interactive-rebase-without-opening-the-editor

  # Aka `git ria ${commit}^`
  GIT_SEQUENCE_EDITOR=: git rebase -i --autosquash ${commit}^

  if ${pop_after}; then
    # Aka `git pop1`
    git reset --mixed @~1
    git --no-pager log -1 --pretty=oneline --abbrev-commit
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# BEWARE: git-reset is not nice to hard links -- if we were to WIP-commit
# uncommitted changes from a hard link, a git-reset breaks the hard link.
#
# - So examine changed files, and check if any have +1 links:
#     find . ! -name . -prune -links +1  # report files in current directory
#     find . ! -name . -prune ! -type d -links +1  # exclude directories
#     find . ! -name . ! -type d -links +1  # descend into directories
#   Check a single file instead...
#     find ${file} -prune ! -type d -links +1
#   List staged files (which we don't care about; these get fup'ed):
#     git --no-pager diff --name-only --cached
#     git --no-pager diff --name-only --staged  # Newer Git alias option
#   List modified, unstaged files (what we want to check for links):
#     git ls-files -m  # aka `git ls-files --modified`
#     git --no-pager diff --name-only
#   Altogether now:
#     git --no-pager diff --name-only | xargs -I {} find {} -links +1 | wc -l

must_not_have_unstaged_hard_link_changes () {
  if [ -n "$( \
    git --no-pager diff --name-only | xargs -I {} find {} -links +1 \
  )" ]; then
    echo "ERROR: Cannot process: There are hard links with unstaged changes."
    echo "       This command clobbers such hard links. You don't want that."
    echo "       HINT: Commit hard linked changes first, then retry git-fup."

    return 1
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  git_fixup_and_rebase "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

